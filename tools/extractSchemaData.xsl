<xsl:stylesheet xmlns="http://www.tei-c.org/ns/1.0"
                xpath-default-namespace="http://www.tei-c.org/ns/1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:rng="http://relaxng.org/ns/structure/1.0"
                version="2.0" xmlns:rsw="http://richard-strauss-ausgabe.de/ns/1.0" exclude-result-prefixes="xsl rng rsw">

    <xsl:param name="rngCollectionPath"/>
    <xsl:param name="meiSassFileName"/>
    <xsl:param name="teiSassFileName"/>
    <xsl:param name="targetSassFileName"/>
    <xsl:param name="targetXmlFileName"/>

    <xsl:variable name="rngCollection" select="collection($rngCollectionPath)"/>
    
    <xsl:output method="xml" indent="yes" encoding="utf-8"/>

    <xsl:template match="/">
        <output>
            <xsl:variable name="output">

                <xsl:variable name="choiceResults">
                    <xsl:for-each select="$rngCollection//rng:choice[rng:value]">
                        <list>
                            <xsl:choose>

                                <xsl:when test="parent::rng:attribute">
                                    <xsl:variable name="thisName" select="string-join(./ancestor-or-self::*/@name, '-')"/>
                                    <xsl:attribute name="xml:id">
                                        <xsl:value-of select="$thisName"/>
                                    </xsl:attribute>
                                    <xsl:attribute name="sassVarName">
                                        <xsl:value-of select="rsw:escapeForSassVarName($thisName)"/>
                                    </xsl:attribute>
                                    <xsl:if test="../parent::rng:optional">
                                        <xsl:attribute name="optional">
                                            <xsl:text>true</xsl:text>
                                        </xsl:attribute>
                                    </xsl:if>
                                    <xsl:attribute name="xml:base">
                                        <xsl:value-of select="base-uri()"/>
                                    </xsl:attribute>
                                </xsl:when>

                                <xsl:otherwise>
                                    <xsl:variable name="thisName" select="ancestor::rng:define/@name"/>
                                    <xsl:attribute name="xml:id">
                                        <xsl:value-of select="$thisName"/>
                                    </xsl:attribute>
                                    <xsl:attribute name="sassVarName">
                                        <xsl:value-of select="rsw:escapeForSassVarName($thisName)"/>
                                    </xsl:attribute>
                                    <xsl:if test="$rngCollection//rng:ref[@name=$thisName][parent::rng:optional or (parent::rng:attribute and ../parent::rng:optional)]">
                                        <xsl:attribute name="optional">
                                            <xsl:text>true</xsl:text>
                                        </xsl:attribute>

                                    </xsl:if>
                                </xsl:otherwise>

                            </xsl:choose>

                            <xsl:for-each select="rng:value">
                                <item n="{.}">
                                    <xsl:variable name="desc" select="following-sibling::*[1][self::*:documentation]"/>
                                    <xsl:value-of select="rsw:formatListEntry($desc)"/>
                                </item>
                            </xsl:for-each>
                        </list>
                    </xsl:for-each>
                </xsl:variable>

                <xsl:variable name="uniqueChoiceResults">
                    <xsl:variable name="uniqueKeys" select="distinct-values($choiceResults//*:list/@xml:id)"/>
                    <xsl:for-each select="$uniqueKeys">
                        <xsl:copy-of select="$choiceResults//*:list[@xml:id=current()][1]"/>
                    </xsl:for-each>
                </xsl:variable>

                <xsl:copy-of select="$uniqueChoiceResults"/>

            </xsl:variable>
            <xsl:copy-of select="$output"/>

            <!-- export variables used in the SCSS code to XML -->
            <xsl:if test="$meiSassFileName and $teiSassFileName and $targetXmlFileName">
                <xsl:variable name="sassFileContent" select="concat(unparsed-text($teiSassFileName), unparsed-text($meiSassFileName))"/>
                <xsl:result-document href="{$targetXmlFileName}" method="xml" indent="yes" encoding="UTF-8">
                    <div xmlns="http://www.tei-c.org/ns/1.0">
                        <xsl:text>&#xa;</xsl:text>
                        <xsl:comment> This file is auto-generated by [RSW oXygen framework project root]/tools/extractSchemaData.xsl </xsl:comment>
                        <xsl:text>&#xa;</xsl:text>
                        <xsl:comment> Any manual changes are lost when rebuilding the project. </xsl:comment>
                        <xsl:text>&#xa;</xsl:text>
                        <xsl:comment> To update the content, call "ant xslt", "ant build" or "ant dist". </xsl:comment>
                        <xsl:text>&#xa;</xsl:text>
                        <xsl:for-each select="$output//@sassVarName">
                           <xsl:if test="contains($sassFileContent, .)">
                               <xsl:variable name="list" select="ancestor::*:list"/>
                               <list xml:id="{$list/@xml:id}">
                                   <xsl:copy-of select="$list/node()"/>
                               </list>
                           </xsl:if>
                        </xsl:for-each>
                    </div>
                </xsl:result-document>
            </xsl:if>

            <xsl:if test="$targetSassFileName">
                <xsl:result-document href="{$targetSassFileName}" method="text">
                    <xsl:call-template name="sassOutput">
                        <xsl:with-param name="input">
                            <xsl:copy-of select="$output"/>
                        </xsl:with-param>
                    </xsl:call-template>
                </xsl:result-document>
            </xsl:if>
        </output>
    </xsl:template>

    <xsl:template name="sassOutput">
        <xsl:param name="input"/>
        <xsl:text>@charset "UTF-8";</xsl:text>
        <xsl:text>&#xa;</xsl:text>
        <xsl:text>&#xa;</xsl:text>
        <xsl:text>// This file is auto-generated by [RSW oXygen framework project root]/tools/extractSchemaData.xsl&#xa;</xsl:text>
        <xsl:text>// Any manual changes are lost when rebuilding the project.&#xa;</xsl:text>
        <xsl:text>// To update the content, call "ant xslt", "ant build" or "ant dist".&#xa;</xsl:text>
        <xsl:text>&#xa;</xsl:text>

        <xsl:text>&#xa;</xsl:text>

        <xsl:for-each select="$input//*:list">
            <xsl:variable name="name" select="@sassVarName"/>
            <xsl:variable name="optionalText">
                <xsl:if test="@optional='true'">
                    <xsl:text>, </xsl:text>
                </xsl:if>
            </xsl:variable>
            <xsl:text>&#xa;</xsl:text>
            <xsl:text>$values-</xsl:text>
            <xsl:value-of select="$name"/>
            <xsl:text>:"</xsl:text>
            <xsl:copy-of select="$optionalText"/>
            <xsl:variable name="values">
                <xsl:for-each select=".//*:item">
                    <value>
                        <xsl:choose>
                            <xsl:when test="@n">
                                <xsl:value-of select="replace(replace(@n, ',', '\${comma}'), '&quot;', '\\&quot;')"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:text/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </value>
                </xsl:for-each>
            </xsl:variable>
            <xsl:value-of select="string-join($values/*, ', ')"/>
            <xsl:text>";</xsl:text>
            <xsl:text>&#xa;</xsl:text>

            <xsl:text>$labels-</xsl:text>
            <xsl:value-of select="$name"/>
            <xsl:text>:"</xsl:text>
            <xsl:copy-of select="$optionalText"/>
            <xsl:variable name="labels">
                <xsl:for-each select=".//*:item">
                    <label>
                        <xsl:choose>
                            <xsl:when test="text()">
                                <xsl:value-of select="replace(replace(text(), ',', '\${comma}'), '&quot;', '\\&quot;')"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:text/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </label>
                </xsl:for-each>
            </xsl:variable>
            <xsl:value-of select="string-join($labels/*, ', ')"/>
            <xsl:text>";</xsl:text>
            <xsl:text>&#xa;</xsl:text>
        </xsl:for-each>
    </xsl:template>
    <!-- normalizes the input string; if it starts
        with \(.*\), only the content between the first parentheses is sent to the output -->
    <xsl:function name="rsw:formatListEntry">
        <xsl:param name="input"/>
        <xsl:choose>
            <xsl:when test="matches($input, '^\(.*\)')">
                <xsl:value-of select="normalize-space(
                    substring(substring-before($input, ')'), 2))"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="normalize-space($input)"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>

    <!-- escape characters in strings used ass Sass variable names -->
    <xsl:function name="rsw:escapeForSassVarName">
        <xsl:param name="input"/>
        <xsl:value-of select="translate($input, '\.:','--')"/>
    </xsl:function>

</xsl:stylesheet>